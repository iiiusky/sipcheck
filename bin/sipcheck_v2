#!/usr/bin/env python
# -*- coding: UTF-8 -*-
'''
    SIPCheck is a tool that parse the file /var/log/asterisk/messages looking for error and
    warnings messages from unauthorized access or trying calls from anonymous users and add
    their ip to the firewall and warns to sinologic server to add for global list of banned
    ip.
'''

'''
    Check if our database is available and get when was the last time we run this script

    Database has got this tables:
	- ipbanned : table with the list of the ip banned on Sinologic.
	- configure: table with the values of:
		+ last time we run this script
		+ datetime of the ipbanned table
		+
	- ipsuspect: table with the list of the ip suspected of attacks


    1. Get all values of the "configure" table.
    2. Check the datetime of the ipbanned table:
    2.1. If datetime is > 48 h, connect to Sinologic and download the new list of ip banned.
    3. Check /var/log/asterisk/messages and looking for 'Wrong password' or 'rejected' words
    3.1. For each line found, we parser the line and get the IP address suspected (IPAS).
    3.2. If IPAS exists in ipsuspect table, do nothing. Else, insert into the ipsuspect table.
    4. Once the parser has finished to analyze the log file, create a request to send like POST method all ipsuspect found.
    5. If it is required, add to the firewall new ip address suspected.

'''

import argparse
import sys
import re
import os
import time
import logging

from sipcheck.config import Config
from sipcheck.db import DB

LEVELS = {'debug': logging.DEBUG,
          'info': logging.INFO,
          'warning': logging.WARNING,
          'error': logging.ERROR,
          'critical': logging.CRITICAL}

def is_attack(line):
    if "rejected" in line:
        return True
    if "Wrong password" in line:
        return True
    return False

def add_ip(db, ipaddress):
    db.insert_ip(ipaddress)

def setup_logger(logfile, loglevel):
    logformat = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    logger.info("Internal logs will be stored at %s file." %
        config.get_general('logfile'))
    # create a file handler
    handler = logging.FileHandler(logfile)
    handler.setLevel(level=LEVELS[loglevel])

    # create a logging format
    formatter = logging.Formatter(logformat)
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logging.basicConfig(level=LEVELS[loglevel])

if __name__ == '__main__':
    logger = logging.getLogger('sipcheck')
    try:
        parser = argparse.ArgumentParser(description='SIPCheck')
        parser.add_argument('-c', action="store", dest="config_file")
        cargs = parser.parse_args()

        print "Reading configuration from file %s" % cargs.config_file
        config = Config(cargs.config_file)

        setup_logger(
            config.get_general('logfile'), config.get_general('loglevel') )

        logger.debug("Ussing %s file as database" %
            config.get_database('file'))
        db = DB(config.get_database('file'))
        if db.exists() is not True:
            logger.debug("DataBase don't exists, creating...")
            db.create_table()

        if db.check() is not True:
            logger.error("ERROR: Can't create database file.")
            sys.exit(-1)

        logger.debug("Reading logs from %s" %
            config.get_general('messagefile'))
        if config.get_general('useiptables'):
            logger.info("Will block IPs with iptables")

        asterisk_log = open(config.get_general('messagefile'), 'r')

        #Find the size of the file and move to the end
        st_results = os.stat(config.get_general('messagefile'))
        st_size = st_results[6]
        asterisk_log.seek(st_size)
        while True:
            where = asterisk_log.tell()
            line  = asterisk_log.readline()

            if not line:
                time.sleep(0.2)
                asterisk_log.seek(where)
            else:
                if is_attack(line):
                    ip = re.findall( r'[0-9]+(?:\.[0-9]+){3}', line )[0]
                    add_ip(db, ip)

    except KeyboardInterrupt:
        logger.error("KeyboardInterrupt form SIPCheck. Stoping")
        # do nothing here
    finally:
        logger.info("SIPCheck stoped")


